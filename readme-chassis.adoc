= Microservice Chassis
:toc:


== Externalized configuration

This chassis reads all configuration from an external Spring Cloud Config Server (make sure that there is an running config server). Take a look at Config Server project https://github.com/wanderleisouza/config-server/blob/master/README.adoc[README.adoc] file for additional details.

	curl -s http://localhost:8888/customer/dev | pjson
	
Every microservice *client* must add the `spring-cloud-starter-config` dependency to the project

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
		
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
		
And in `boostrap.yml` file, insert the microservice *application name* and the default profile.

	spring:
	   application:
	      name: customer
	   profiles:
	      default: dev

Use a spring profile to start the application. The profile `-Dspring.profiles.active=dev` will read properties from `application.yml`, `customer.yml` and `customer-dev.yml` files from config server/github repo.

NOTE: `redis-server` must be started with `--protected-mode no` option to accept remote connections from a docker container machine

	mvn spring-boot:run -Dspring.profiles.active=dev -Dspring.cloud.config.uri=http://localhost:8888

...as an alternative, you can run the microservice as a docker container 
	

	mvn clean package jib:dockerBuild -Dimage=examples/customer
	
	docker run --env spring.profiles.active=dev,docker --env spring.cloud.config.uri=http://host.docker.internal:8888 -p 8080:8080 examples/customer


== Logging 

Spring-boot defaults:

* SLF4J: Logging facade
* Logback: SLF4J implementation

A twelve-factor app never concerns itself with routing or storage of its output stream. It should not attempt to write to or manage logfiles. Instead, each running process writes its event stream, unbuffered, to `stdout`

The Spring Boot logger is configured to only log messages of `INFO` level or higher. We can see the `TRACE` and `DEBUG` messages if we add the following to our `application.properties` file

	logging.level.com.example=DEBUG


== Health checks
== Metrics
== Distributed tracing