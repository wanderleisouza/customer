= Microservice Chassis
:toc:


== Externalized configuration

Applications sometimes store config as constants in the code. This is a violation of best practices, which *requires strict separation of config from code*.

This chassis reads all configuration from an external Spring Cloud Config Server (make sure that there is an running config server). Take a look at Config Server project https://github.com/wanderleisouza/config-server/blob/master/README.adoc[README.adoc] file for additional details.

	curl -s http://localhost:8888/customer/dev | pjson
	
Every microservice *client* must add the `spring-cloud-starter-config` dependency to the project

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
		
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
		
And in `boostrap.yml` file, insert the microservice *application name* and the default profile.

	spring:
	   application:
	      name: customer
	   profiles:
	      default: dev

Use a spring profile to start the application. The profile `-Dspring.profiles.active=dev` will read properties from `application.yml`, `customer.yml` and `customer-dev.yml` files from config server/github repo.

NOTE: `redis-server` must be started with `--protected-mode no` option to accept remote connections from a docker container machine

	mvn spring-boot:run -Dspring.profiles.active=dev -Dspring.cloud.config.uri=http://localhost:8888

...as an alternative, you can run the microservice as a docker container 
	

	mvn clean package jib:dockerBuild -Dimage=examples/customer
	
	docker run --env spring.profiles.active=dev,docker --env spring.cloud.config.uri=http://host.docker.internal:8888 -p 8080:8080 examples/customer


== Logging 

Spring-boot defaults:

* SLF4J: Logging facade
* Logback: SLF4J implementation

A twelve-factor app never concerns itself with routing or storage of its output stream. It should not attempt to write to or manage logfiles. Instead, each running process writes its event stream, unbuffered, to `stdout`

The Spring Boot logger is configured to only log messages of `INFO` level or higher. We can see the `TRACE` and `DEBUG` messages if we add the following to our `application.yml` file (from config repo)

	logging:
	   level:
	      root: INFO
	      com:
	         example: DEBUG


== Health checks

How to detect that a running service instance is unable to handle requests?

A service has an health check API endpoint (e.g. HTTP `/actuator/health`) that returns the health of the service. 
The API endpoint handler performs various checks, such as

* the status of the connections to the infrastructure services used by the service instance
* the status of the host, e.g. disk space
* application specific logic

To activate a `/actuator/health` endpoint in Spring Boot applications, it is necessary to add the following dependency in your pom.xml

	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-actuator</artifactId>
	</dependency>

...and to show all *health check details*, use this parameters in application.yml file (config server)

	management:
	   endpoint:
	      health:
	         show-details: always

to test the microservice health, with a running application, call `/actuator/health` endpoint

	curl -s http://localhost:8080/actuator/health | pjson


== Metrics
== Distributed tracing