= Microservice Chassis
:toc:


== Externalized configuration

This chassis reads all configuration from an external Spring Cloud Config Server. Take a look at Config Server project https://github.com/wanderleisouza/config-server/blob/master/README.adoc[README.adoc]  file

Every client must add the `spring-cloud-starter-config` dependency to the project

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-config</artifactId>
	</dependency>
		
	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>
		
In `boostrap.yml` file, put the *active profile*, *application name* and *config server* address

	spring:
	  profiles:
	  	active: dev
	  application:
	    name: customer
	  cloud:
	    config:
	      uri: ${SPRING_CONFIG_URI:http://localhost:8888}	 

E.g. the profile `-Dspring.profiles.active=prod` will read properties from `application.yml`, `customer.yml` and `customer-prod.yml` files from config server/github repo.

	mvn spring-boot:run -Dspring.profiles.active=prod
	

== Logging 

Spring-boot defaults:

* SLF4J: Logging facade
* Logback: SLF4J implementation

A twelve-factor app never concerns itself with routing or storage of its output stream. It should not attempt to write to or manage logfiles. Instead, each running process writes its event stream, unbuffered, to `stdout`

The Spring Boot logger is configured to only log messages of `INFO` level or higher. We can see the `TRACE` and `DEBUG` messages if we add the following to our `application.properties` file

	logging.level.com.example=DEBUG


== Health checks
== Metrics
== Distributed tracing